<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kira Chat</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: #000; color: #fff; }
    ::-webkit-scrollbar { display: none; }
    .typing { animation: blink 1s infinite; }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    const App = () => {
      const [messages, setMessages] = useState([]);
      const [input, setInput] = useState('');
      const [loading, setLoading] = useState(false);
      const [isRecording, setIsRecording] = useState(false);
      const recognitionRef = useRef(null);
      const audioRef = useRef(null);

      // Web Speech API Setup
      const startListening = () => {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          alert('Il tuo browser non supporta Web Speech API');
          return;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.lang = 'it-IT';
        recognition.continuous = false;
        recognition.interimResults = false;

        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          setInput(transcript);
        };

        recognition.onend = () => {
          setIsRecording(false);
        };

        recognition.start();
        setIsRecording(true);
        recognitionRef.current = recognition;
      };

      const stopListening = () => {
        if (recognitionRef.current) {
          recognitionRef.current.stop();
          recognitionRef.current = null;
        }
      };

      // Routing logica: semplice â†’ voce, strutturato â†’ voce + testo
      const isStructuredContent = (text) => {
        // Semplice euristica: se ha markdown, codice, o formati specifici â†’ strutturato
        return /```|https?:\/\/|www\.|`|\$|>|</.test(text);
      };

      const send = async () => {
        const text = input.trim();
        if (!text) return;

        setLoading(true);
        const userMsg = { type: 'user', text, structured: isStructuredContent(text) };
        setMessages(prev => [...prev, userMsg]);
        setInput('');

        try {
          const res = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: text, voiceEnabled: !userMsg.structured })
          });
          const data = await res.json();
          
          const aiMsg = { 
            type: 'ai', 
            text: data.response,
            structured: userMsg.structured,
            audioUrl: null 
          };
          
          // Se l'utente non vuole audio o il contenuto Ã¨ strutturato, genera TTS
          if (!userMsg.structured) {
            try {
              const ttsRes = await fetch('/api/tts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: data.response })
              });
              const ttsData = await ttsRes.json();
              if (ttsData.audioUrl) {
                aiMsg.audioUrl = ttsData.audioUrl;
              }
            } catch (e) {
              console.warn('TTS fallito:', e);
            }
          }
          
          setMessages(prev => [...prev, aiMsg]);
        } catch (e) {
          setMessages(prev => [...prev, { type: 'error', text: e.message }]);
        } finally {
          setLoading(false);
        }
      };

      const playAudio = (url) => {
        if (audioRef.current) {
          audioRef.current.pause();
        }
        const audio = new Audio(url);
        audio.onended = () => {
          setMessages(prev => prev.map(m => 
            m.audioUrl === url ? { ...m, audioPlaying: false } : m
          ));
        };
        audio.play();
        audioRef.current = audio;
        
        setMessages(prev => prev.map(m => 
          m.audioUrl === url ? { ...m, audioPlaying: true } : m
        ));
      };

      return (
        <div className="min-h-screen flex flex-col p-4 max-w-2xl mx-auto">
          {/* Header */}
          <div className="flex justify-between items-center mb-4">
            <h1 className="text-2xl font-bold">âš¡ Kira</h1>
            <div className="text-xs text-gray-400 flex gap-2">
              <span>ğŸ“± Push Notifiche: ON</span>
              <span>ğŸ“… Calendario: ON</span>
              <span>ğŸ”” Remind: ON</span>
            </div>
          </div>

          {/* Chat Area */}
          <div className="flex-1 space-y-4 overflow-y-auto pb-20">
            {messages.map((m, i) => (
              <div key={i} className={`flex ${m.type === 'user' ? 'justify-end' : 'justify-start'}`}>
                <div className={`max-w-[80%] rounded-2xl p-4 ${
                  m.type === 'user' ? 'bg-blue-600' : 
                  m.type === 'error' ? 'bg-red-900' : 'bg-gray-800'
                }`}>
                  {m.audioPlaying && (
                    <div className="text-xs text-blue-400 mb-2">
                      ğŸ”Š TTS in riproduzione...
                    </div>
                  )}
                  {m.audioUrl ? (
                    <button 
                      onClick={() => playAudio(m.audioUrl)}
                      className="flex items-center gap-2 text-blue-400 hover:text-blue-300 mb-2"
                    >
                      <span>ğŸ”Š</span>
                      <span className="text-sm">Ascolta</span>
                    </button>
                  ) : m.type === 'ai' && m.structured && (
                    <div className="text-xs text-green-400 mb-2">
                      ğŸ“„ Contenuto strutturato â€” testo disponibile
                    </div>
                  )}
                  <div className="whitespace-pre-wrap">{m.text}</div>
                </div>
              </div>
            ))}
            {loading && <div className="text-gray-400">âš¡ Kira sta pensando...</div>}
          </div>

          {/* Input Area */}
          <div className="fixed bottom-0 left-0 right-0 p-4 bg-black border-t border-gray-800">
            <div className="max-w-2xl mx-auto flex gap-2">
              {/* Mic Button */}
              <button
                onClick={() => isRecording ? stopListening() : startListening()}
                className={`p-3 rounded-xl transition-all ${
                  isRecording ? 'bg-red-600 animate-pulse' : 'bg-gray-700 hover:bg-gray-600'
                }`}
              >
                <span className="text-2xl">{isRecording ? 'ğŸ¤' : 'ğŸ™ï¸'}</span>
              </button>

              {/* Text Input */}
              <input
                value={input}
                onChange={e => setInput(e.target.value)}
                onKeyPress={e => e.key === 'Enter' && send()}
                placeholder={isRecording ? "Ascoltando..." : "Scrivi o premi ğŸ™ï¸"}
                className="flex-1 bg-gray-900 rounded-xl p-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                disabled={isRecording}
              />

              {/* Send Button */}
              <button
                onClick={send}
                disabled={loading || !input.trim()}
                className="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-xl font-semibold disabled:opacity-50"
              >
                <span className="text-xl">ğŸš€</span>
              </button>
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
